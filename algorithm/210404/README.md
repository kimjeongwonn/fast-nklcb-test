> 개인 노션에 정리한 내용을 올리다보니 평어체로 작성된 점 양해해 주시면 감사하겠습니다 🥲

주말 내내 문제와 씨름하다 결국 포기했다. 블로그에서 해설을 보고 나서도 온전히 내 생각만으로는 풀지 못했을 것 같은 느낌을 받았다. 2시간 이상 풀지 못하는 문제는 얼른 포기하고 해설을 보는 게 더 빨리 배울 수 있는 방법같다는 것을 확실하게 배웠다.

### 나의 오답

내가 계속해서 접근한 방법은 이분탐색을 통해 돌의 위치를 찾는 방식이나, 임의의 돌을 삭제했을 때 최소값을 찾는 등의 접근 방식에서 벗어나지를 못했다. 해답을 보고 나서 생각해 보면 정말 엉뚱한 방식으로 접근을 했었다. 가장 큰 문제는 내가 그 강이라는 공간에서 벗어나질 못했다는 것. 이분탐색을 어떤 사이즈.. 보다는 강의 특정위치를 생각하면서 접근하다 보니 정답의 접근에 가까워질 수가 없었다. 앞으로는 한가지 가정을하고 접근을 했을 때 답이 없다면 완전히 다른 접근을 할 수 있는 능력을 키워야겠다.

### 해답

해답은 다양한 풀이가 있지만 내가 이해할 수 있는 결론적인 해답은, **모든 돌 사이의 거리가 k보다 클 때 돌이 제거된 갯수가 n개 이하인 경우의 k의 값을 찾아내는 것이다.** 여기서 k는 최대값을 구해야 한다.

즉 이분 탐색을 통해 돌 사이의 간격이 모두 k 이상이 되었을때 몇개의 돌을 제거해야 하는가를 찾아내고 k가 n개의 돌을 제거하는 최대값이 되면 k를 반환하면 된다.

### 정답

```python
def solution(distance, rocks, n):
    rocks.sort()  # 돌을 정렬해준다
    rocks.append(distance)  # 도착점까지 넣어준다
    answer = 0
    left = 0
    right = distance
    while left <= right:
        rm_rocks_cnt = 0
        mid = (left+right) // 2  # 탐색을 할 기준을 찾아준다
        prev_rock = 0  # 거리를 파악할 기준이 될 돌의 위치
        for i in range(len(rocks)): # 모든 돌을 건넌다
            curr_rock = rocks[i] # 기준과 비교될 돌을 지정
            if curr_rock - prev_rock < mid: # 만약 기준돌과의 거리가 mid보다 작다면
                rm_rocks_cnt += 1 # 해당돌은 제거되고 다음돌과의 거리를 비교
            else: # 기준돌과 거리가 mid와 같거나 크다면 (돌을 제거할 수 없다면)
                prev_rock = curr_rock # 기준이 되는 돌을 현재 위치로 옮기고 다음돌과 거리를 비교
        # 모든 돌을 제거한 뒤
        if rm_rocks_cnt <= n:
            # 제거한 돌이 n개 보다 적다면 -> 더 많은 돌을 제거하기 위해 더 큰 값을 탐색
            # 제거한 돌이 n개 라면 -> 최대값을 찾기 위해 더 큰 값을 탐색
            answer = max([mid, answer]) # 저장된 값과 새로찾은 값 중 더 큰 값을 저장
            left = mid+1 # 더 큰 값을 탐색
        else: # 제거한 돌이 n개 보다 많다면
            right = mid-1 # 더 적은 돌을 제거하기 위해 더 작은 값을 탐색

    return answer
```

인터넷 자료들을 참고해서 다시 로직을 짜 보았다. 결국 변수명이나 반복의 방법에서 조금의 차이만 있을 뿐 모두가 비슷한 방법으로 풀었다.
